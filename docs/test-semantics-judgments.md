# Test Refactor Notes (Inference-Rule Style)

This note specifies test obligations as judgments in a PLT/compilers style.
Judgments are encoded as tests generated by macros.

======================================================================
PART I: Kubernetes API Type System
======================================================================

## 1. Upstream Kubernetes Interface Hierarchy

Kubernetes API machinery defines a layered type system for API objects:

```
                    ┌─────────────────────────────────────────┐
                    │           runtime.Object                │
                    │  GetObjectKind() schema.ObjectKind      │
                    │  DeepCopyObject() Object                │
                    └─────────────────┬───────────────────────┘
                                      │
              ┌───────────────────────┴───────────────────────┐
              │                                               │
              ▼                                               ▼
┌─────────────────────────────┐             ┌─────────────────────────────┐
│   metav1.ObjectMetaAccessor │             │   metav1.ListMetaAccessor   │
│   GetObjectMeta() Object    │             │   GetListMeta() ListInterface│
└─────────────────────────────┘             └─────────────────────────────┘
              │                                               │
              ▼                                               ▼
┌─────────────────────────────┐             ┌─────────────────────────────┐
│      metav1.Object          │             │    metav1.ListInterface     │
│  Name, Namespace, UID,      │             │  ResourceVersion, Continue, │
│  Labels, Annotations, ...   │             │  RemainingItemCount         │
└─────────────────────────────┘             └─────────────────────────────┘
```

Source: `k8s.io/apimachinery/pkg/runtime/interfaces.go`,
        `k8s.io/apimachinery/pkg/apis/meta/v1/meta.go`

### 1.1 runtime.Object (interfaces.go:337-340)

The minimal contract for ALL Kubernetes API types:

```go
type Object interface {
    GetObjectKind() schema.ObjectKind  // Access apiVersion, kind
    DeepCopyObject() Object            // Safe cloning for controllers
}
```

Both resource objects (Pod) AND list objects (PodList) implement this.

### 1.2 schema.ObjectKind

Implemented by embedding `TypeMeta`:

```go
type TypeMeta struct {
    Kind       string `json:"kind,omitempty"`
    APIVersion string `json:"apiVersion,omitempty"`
}

func (obj *TypeMeta) GetObjectKind() schema.ObjectKind { return obj }
func (obj *TypeMeta) SetGroupVersionKind(gvk schema.GroupVersionKind) { ... }
func (obj *TypeMeta) GroupVersionKind() schema.GroupVersionKind { ... }
```

### 1.3 Metadata Dichotomy: ObjectMeta vs ListMeta

Resource objects embed `ObjectMeta`:
```go
type Pod struct {
    metav1.TypeMeta   `json:",inline"`
    metav1.ObjectMeta `json:"metadata,omitempty"`  // Name, Namespace, UID, ...
    Spec   PodSpec
    Status PodStatus
}
```

List objects embed `ListMeta`:
```go
type PodList struct {
    metav1.TypeMeta `json:",inline"`
    metav1.ListMeta `json:"metadata,omitempty"`  // ResourceVersion, Continue
    Items []Pod
}
```

Key distinction: Lists do NOT have Name, Namespace, UID, etc.

----------------------------------------------------------------------
## 2. The Scheme: Type Registry and Operations

The `runtime.Scheme` is Kubernetes' central type registry:

```go
// Registration (register.go)
func addKnownTypes(scheme *runtime.Scheme) error {
    scheme.AddKnownTypes(SchemeGroupVersion,
        &Pod{},
        &PodList{},
        ...
    )
    return nil
}
```

### 2.1 Scheme Responsibilities

| Operation | Method | Purpose |
|-----------|--------|---------|
| Type → GVK | `scheme.ObjectKinds(obj)` | Reflection: Go type to GroupVersionKind |
| GVK → Type | `scheme.New(gvk)` | Factory: create instance from GVK |
| Defaulting | `scheme.Default(obj)` | Apply default values (ObjectDefaulter) |
| Conversion | `scheme.Convert(in, out, ctx)` | Version conversion (ObjectConvertor) |

### 2.2 ObjectDefaulter (interfaces.go:254-258)

```go
type ObjectDefaulter interface {
    Default(in Object)  // Apply defaults; must not error
}
```

Defaulting fills:
- `TypeMeta` (apiVersion, kind) from scheme registration
- Spec field defaults (e.g., `restartPolicy: Always` for Pod)

### 2.3 ObjectConvertor (interfaces.go:266-279)

```go
type ObjectConvertor interface {
    Convert(in, out, context interface{}) error
    ConvertToVersion(in Object, gv GroupVersioner) (Object, error)
    ConvertFieldLabel(gvk, label, value string) (string, string, error)
}
```

Conversion path: `v1.Pod ↔ internal.Pod ↔ v1beta1.Pod`

----------------------------------------------------------------------
## 3. Internal vs External Types

### 3.1 External Types (Versioned)

- Carry `TypeMeta` (apiVersion, kind)
- Used for serialization/deserialization
- User-facing API surface
- Example: `k8s.io/api/core/v1.Pod`

### 3.2 Internal Types (Unversioned)

- NO `TypeMeta` (version-agnostic)
- Used for business logic in controllers
- Hub for multi-version conversion
- Example: `k8s.io/kubernetes/pkg/apis/core.Pod`

```
External v1 ──┐
              │
External v2 ──┼──► Internal (hub) ──► Business Logic
              │
External v3 ──┘
```

======================================================================
PART II: Taibai Trait Mapping
======================================================================

## 4. Correspondence Table

| Kubernetes Concept | Taibai Trait | Notes |
|--------------------|--------------|-------|
| `runtime.Object` | `HasTypeMeta` | Access to apiVersion/kind |
| `schema.ObjectKind` | `TypeMeta` struct | The actual GVK data |
| `metav1.ObjectMetaAccessor` | `HasObjectMeta` | Returns accessor (see §4.2) |
| `metav1.Object` | `&ObjectMeta` (struct) | Direct access vs interface |
| `metav1.ObjectMetaAccessor` (external) | `VersionedObject` | Handles Option<ObjectMeta> |
| `metav1.ListMetaAccessor` | (missing) | **Semantic gap** (see §4.3) |
| `metav1.ListInterface` | `ListMeta` struct | List metadata fields |
| `scheme.AddKnownTypes` | `ResourceSchema` | Compile-time GVKR metadata |
| `scheme.Default` | `ApplyDefault` | Fill default values |
| `scheme.Convert` | `ToInternal/FromInternal` | Version conversion |

### 4.1 Key Architectural Difference

Kubernetes: Runtime registration (reflection-based Scheme)
Taibai: Compile-time traits (type-system enforced)

```rust
// Taibai: ResourceSchema provides compile-time GVKR
pub trait ResourceSchema: Send + Sync {
    type Meta: Clone + Send + Sync + Default;
    fn group(meta: &Self::Meta) -> &str;
    fn version(meta: &Self::Meta) -> &str;
    fn kind(meta: &Self::Meta) -> &str;
    fn resource(meta: &Self::Meta) -> &str;
}
```

### 4.2 Deep Dive: ObjectMeta Accessor Pattern

The correspondence between `HasObjectMeta` and Kubernetes interfaces requires
careful analysis due to different language idioms.

#### Kubernetes: Interface-based Accessor (meta.go:25-64)

```go
// Level 1: Accessor that returns the interface
type ObjectMetaAccessor interface {
    GetObjectMeta() Object  // returns metav1.Object, not ObjectMeta struct
}

// Level 2: The accessor interface with 20+ getter/setter methods
type Object interface {
    GetNamespace() string
    SetNamespace(namespace string)
    GetName() string
    SetName(name string)
    GetUID() types.UID
    SetUID(uid types.UID)
    GetLabels() map[string]string
    SetLabels(labels map[string]string)
    GetAnnotations() map[string]string
    SetAnnotations(annotations map[string]string)
    // ... 15+ more methods
}

// ObjectMeta implements metav1.Object
func (meta *ObjectMeta) GetObjectMeta() Object { return meta }
func (meta *ObjectMeta) GetName() string       { return meta.Name }
func (meta *ObjectMeta) SetName(name string)   { meta.Name = name }
// ... all other accessors
```

#### Taibai: Direct Struct Access (traits.rs)

```rust
pub trait HasObjectMeta: Send + Sync {
    fn meta(&self) -> &ObjectMeta;       // returns struct reference
    fn meta_mut(&mut self) -> &mut ObjectMeta;
}
```

#### Comparison

| Aspect | Kubernetes | Taibai |
|--------|------------|--------|
| Pattern | Interface-based accessor | Direct struct access |
| Return type | `metav1.Object` (interface) | `&ObjectMeta` (struct ref) |
| Field access | `obj.GetObjectMeta().GetName()` | `obj.meta().name` |
| Mutability | `obj.GetObjectMeta().SetName(n)` | `obj.meta_mut().name = n` |
| Indirection | Two levels (accessor → interface) | One level (→ struct) |

#### Why the Difference?

Go idiom: Interfaces hide implementation; accessors provide controlled access.
Rust idiom: Borrow checker ensures safety; direct struct access is idiomatic.

```
Kubernetes:                          Taibai:

Pod                                  Pod
 │                                    │
 ▼                                    ▼
GetObjectMeta()                      meta()
 │                                    │
 ▼                                    ▼
metav1.Object (interface)            &ObjectMeta (struct ref)
 │                                    │
 ▼                                    ▼
GetName() → string                   .name → &String
```

#### Corrected Correspondence

```
metav1.ObjectMetaAccessor  ←→  HasObjectMeta
         │                           │
         ▼                           ▼
   metav1.Object             &ObjectMeta (struct)
   (20+ methods)             (direct field access)
```

The `VersionedObject` trait is `HasObjectMeta` specialized for external types
with `Option<ObjectMeta>`, handling None with lazy initialization:

```rust
impl VersionedObject for Pod {
    fn metadata(&self) -> &ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| {
            static DEFAULT: OnceLock<ObjectMeta> = OnceLock::new();
            DEFAULT.get_or_init(ObjectMeta::default)
        })
    }
}

// Auto-impl: VersionedObject → HasObjectMeta
impl<T: VersionedObject> HasObjectMeta for T { ... }
```

----------------------------------------------------------------------
### 4.3 Semantic Gap: HasListMeta

Kubernetes has `metav1.ListMetaAccessor` for list types, but taibai lacks
a corresponding `HasListMeta` trait. Recommended addition:

```rust
pub trait HasListMeta: Send + Sync {
    fn list_meta(&self) -> &ListMeta;
    fn list_meta_mut(&mut self) -> &mut ListMeta;
}
```

======================================================================
PART III: Test Obligation Judgments
======================================================================

## 5. Notation

Domains:
- T : type under test
- ext(T) : T is in the external API domain (versioned)
- list(T) : T is a list/collection type
- int(T) : T is an internal type (unversioned, IR domain)

Judgments (read: "T satisfies ..."):
- VO(T)  : T implements VersionedObject (external objects)
- AD(T)  : T implements ApplyDefault
- RS(T)  : T implements ResourceSchema
- HM(T)  : T implements HasObjectMeta
- LM(T)  : T implements HasListMeta (proposed)
- D(T)   : T implements Default
- CI(T,I): T implements ToInternal<I> and FromInternal<I>

----------------------------------------------------------------------
## 6. Inference Rules

### 6.1 External API rules (object types)

```
   ext(T) ∧ ¬list(T)
   -------------------------------  (EXT-OBJECT)
   VO(T) ∧ AD(T) ∧ RS(T)
```

Corresponds to upstream: `runtime.Object + metav1.ObjectMetaAccessor +
ObjectDefaulter + SchemeRegistration`

### 6.2 External API rules (list types)

```
   ext(T) ∧ list(T)
   --------------------------------------  (EXT-LIST)
   D(T) ∧ AD(T) ∧ RS(T)
```

Note: `list(T) ⟹ ¬VO(T)` — list types embed ListMeta, not ObjectMeta.

Proposed extension (after adding HasListMeta):
```
   ext(T) ∧ list(T)
   --------------------------------------  (EXT-LIST')
   D(T) ∧ AD(T) ∧ RS(T) ∧ LM(T)
```

### 6.3 Internal API rules

```
   int(T)
   -------------------------------  (INT-OBJECT)
   HM(T)
```

Notes:
- Internal types are not required to satisfy RS(T) — they are version-agnostic
- Internal types have non-optional ObjectMeta (Go zero-value semantics)

### 6.4 Conversion coherence rules

```
   ext(E) ∧ int(I)
   --------------------------------------  (CONV)
   CI(E,I)
```

Operationally, tests enforce round-trip coherence:
```
normalize(E) ; to_internal ; from_internal ; normalize ≡ normalize(E)
```

This ensures no information loss through the conversion hub.

----------------------------------------------------------------------
## 7. Macro Encoding

### 7.1 generate_trait_tests!

Encodes:
- EXT-OBJECT for `resources:` parameter
- EXT-LIST for `list_resources:` parameter
- CONV for `resources:` + `internal_resources:` pairs

### 7.2 generate_internal_object_meta_tests!

Encodes:
- INT-OBJECT for internal resources

----------------------------------------------------------------------
## 8. Migration Invariants

**Invariant A (Domain separation):**
  No `list(T)` is tested under EXT-OBJECT rule.

**Invariant B (Internal discipline):**
  Only `HM(T)` is required for internal types; no RS(T) obligation.

**Invariant C (Coverage completeness):**
  For each `ext(T)`, tests cover `RS(T)` and `AD(T)`.

**Invariant D (Conversion symmetry):**
  If `CI(E, I)` holds, both directions (to_internal, from_internal) are tested.

======================================================================
PART IV: Future Work
======================================================================

## 9. Recommended Enhancements

1. **Add HasListMeta trait** — align with metav1.ListMetaAccessor
2. **Update EXT-LIST rule** — include LM(T) obligation
3. **Add prost::Message tests** — protobuf serialization (currently placeholder)
4. **Validation judgments** — V(T) for types with Validate() methods

## 10. References

- `k8s.io/apimachinery/pkg/runtime/interfaces.go` — runtime.Object, ObjectDefaulter
- `k8s.io/apimachinery/pkg/apis/meta/v1/types.go` — TypeMeta, ObjectMeta, ListMeta
- `k8s.io/apimachinery/pkg/apis/meta/v1/meta.go` — accessor interfaces
- `k8s.io/api/core/v1/register.go` — scheme registration example
